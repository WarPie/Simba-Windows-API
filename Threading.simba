// Simple threading utilities for lape on Windows.
// Could contain mistakes on my part, it's not well tested..
{$include_once Windows/Windows.simba}

type 
  TLapeThreadProc = LPTHREAD_START_ROUTINE;
  TLapeThread = record
    FHandle: HANDLE;
    FThreadID: DWORD;
    FMethod: TLapeThreadProc;
    FArgs: Pointer;
  end;


  TLapeTimerProc = procedure();
  TLapeTimer = ^TLapeTimerRec;
  TLapeTimerRec = record
    FHandle: HANDLE;
    FThreadID: DWORD;
    FOnTimer: TLapeTimerProc;
    FInterval: Int32;
    FEnabled: Boolean;
  end;


// -----------------------------------------------------------------------------
// Simple lape threading
//
function TLapeThread.Create(Method: TLapeThreadProc; Args: Pointer): TLapeThread; static;
begin
  Result.FArgs   := Args;
  Result.FMethod := Method;
  Result.FHandle := Windows.CreateThread(nil, 0, Result.FMethod, Result.FArgs, CREATE_SUSPENDED, @Result.FThreadID);
end;

function TLapeThread.Recreate(): Boolean;
begin
  if Self.FHandle <> 0 then Exit(False);
  Self.FHandle := Windows.CreateThread(nil, 0, Self.FMethod, Self.FArgs, CREATE_SUSPENDED, @Self.FThreadID);
end;

procedure TLapeThread.Terminate();
var excode: DWORD;
begin
  Windows.GetExitCodeThread(Self.FHandle, excode);
  Windows.TerminateThread(Self.FHandle, excode);
  Self.FHandle   := 0;
  Self.FThreadID := 0;
end;

procedure TLapeThread.Execute();
begin
  Windows.ResumeThread(Self.FHandle);
end;

procedure TLapeThread.Suspend();
begin
  Windows.SuspendThread(Self.FHandle);
end;

procedure TLapeThread.Resume();
begin
  Windows.ResumeThread(Self.FHandle);
end;



// -----------------------------------------------------------------------------
// Simple lape timer - Note that it will not create overlapping threads!
// Interval is just the minimum time between execution of the timer-method.
function TLapeTimer.Create(OnTimer: TLapeTimerProc; Interval:Int32): TLapeTimer; static;
begin
  Result := AllocMem(SizeOf(TLapeTimerRec));
  Result^.FOnTimer  := @OnTimer;
  Result^.FInterval := Interval;
  Result^.FEnabled  := True;
  Result^.FHandle   := Windows.CreateThread(nil, 0, TLapeTimer.TimerProc, Result, CREATE_SUSPENDED, @Result^.FThreadID);
end;

procedure TLapeTimer.Terminate();
begin
  Self^.FEnabled  := False;
  Self^.FHandle   := 0;
  Self^.FThreadID := 0;
  Windows.WaitForSingleObject(Self^.FHandle, $FFFFFFFF);
  FreeMem(Self);
end;

procedure TLapeTimer.Start();
begin
  Windows.ResumeThread(Self^.FHandle);
end;

procedure TLapeTimer.Pause();
begin
  Windows.SuspendThread(Self^.FHandle);
end;

function TLapeTimer.Handle(): HANDLE;
begin
  Result := Self^.FHandle;
end;

function TLapeTimer.ThreadID(): DWORD;
begin
  Result := Self^.FThreadID;
end;

function TLapeTimer.GetInterval(): Int32;
begin
  Result := Self^.FInterval;
end;

procedure TLapeTimer.SetInterval(Value: Int32);
begin
  Self^.FInterval := Value;
end;

procedure TLapeTimer.SetOnTimer(OnTimer: TLapeTimerProc);
begin
  Self^.FOnTimer := @OnTimer;
end;

function TLapeTimer.GetOnTimer(): TLapeTimerProc;
begin
  Result := @Self^.FOnTimer;
end;

procedure TLapeTimer.TimerProc(argz:Pointer); static;
var
  t: TDateTime;
  sleepFor: Int32;
begin
  while TLapeTimer(argz)^.FEnabled  do
  begin
    t := Now();
    TLapeTimer(argz)^.FOnTimer();
    sleepFor := TLapeTimer(argz)^.FInterval - Trunc((Now()-t)*86400000);
    if sleepFor > 0 then
      Sleep(sleepFor);
  end;
end;



// -----------------------------------------------------------------------------
// WriteLn that works across threads (not really threadsafe tho)
var __WRITE_QUEUE: String;
procedure _Write(str: String); override;
begin
  __WRITE_QUEUE += str;
end;
procedure _writeln; override;
begin
  client.WriteLn(__WRITE_QUEUE);
  __WRITE_QUEUE := [];
end;


{$IFDEF THREADED_MML}
{$include_once threading/mml.pas}
{$ENDIF}
